<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waku Collaborative Whiteboard</title>
    <script src="https://cdn.jsdelivr.net/npm/protobufjs@7.5.3/dist/protobuf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: white;
            padding: 1rem;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .connection-status {
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .connected {
            background: #e8f5e8;
            color: #2d5a2d;
        }

        .connecting {
            background: #e1a485;
            color: #461900;
        }

        .disconnected {
            background: #ffeaea;
            color: #8b0000;
        }

        .toolbar {
            background: white;
            padding: 1rem;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .tool-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .tool-group label {
            font-size: 0.9rem;
            color: #666;
        }

        .color-picker {
            width: 40px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            background: none;
            outline: none;
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 4px;
        }

        .color-picker::-moz-color-swatch {
            border: none;
            border-radius: 4px;
        }

        .brush-size {
            width: 100px;
        }

        .clear-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
        }

        .clear-btn:hover {
            background: #ff3742;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        #whiteboard {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: crosshair;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .pending-strokes {
            position: fixed;
            top: 100px;
            right: 20px;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-width: 200px;
        }

        .pending-stroke {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            margin: 0.25rem 0;
            background: #fff3cd;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .pending-stroke.acknowledged {
            background: #d4edda;
        }

        .spinner {
            width: 12px;
            height: 12px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .checkmark {
            color: #28a745;
            font-weight: bold;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


    </style>
</head>
<body>
    <div class="header">
        <div class="title">ðŸŽ¨ Waku Collaborative Whiteboard</div>
        <div class="status">
            <div class="connection-status disconnected" id="connectionStatus">Disconnected</div>
        </div>
    </div>

    <div class="toolbar">
        <div class="tool-group">
            <label>Color:</label>
            <input type="color" class="color-picker" id="colorPicker" value="#000000">
        </div>
        <div class="tool-group">
            <label>Size:</label>
            <input type="range" class="brush-size" id="brushSize" min="1" max="20" value="3">
            <span id="brushSizeValue">3px</span>
        </div>
        <button class="clear-btn" id="clearBtn">Clear Canvas</button>
    </div>

    <div class="canvas-container">
        <canvas id="whiteboard" width="800" height="600"></canvas>
    </div>

    <div class="pending-strokes" id="pendingStrokes" style="display: none;">
        <h4>Pending Messages</h4>
        <div id="pendingList"></div>
    </div>

    <script type="module">
        import {
            createLightNode,
            MessageChannelEvent,
            MessageChannel,
            HealthStatus
        } from 'https://unpkg.com/@waku/sdk@0.0.34-ced989a.0/bundle/index.js';

        // Define protobuf schema for whiteboard messages
        const protoSchema = `
            syntax = "proto3";
            
            message WhiteboardMessage {
                uint64 timestamp = 1;
                string userId = 2;
                string messageId = 3;
                 oneof content {
                     StrokeData stroke = 4;
                     ClearData clear = 5;
                 }
            }
            
            message StrokeData {
                string id = 1;
                repeated Point points = 2;
                string color = 3;
                int32 size = 4;
            }
            
            message Point {
                float x = 1;
                float y = 2;
            }
            
             message ClearData {
                bool clearAll = 1;
            }
        `;

        class CollaborativeWhiteboard {
            constructor() {
                this.canvas = document.getElementById('whiteboard');
                this.ctx = this.canvas.getContext('2d');
                this.contentTopic = '/collaborative-board/1/all/proto';
                this.isDrawing = false;
                this.currentStroke = [];
                this.pendingStrokes = new Map();
                this.acknowledgedStrokes = new Set();
                this.localStrokes = new Map(); // Track local strokes and their status
                this.userId = this.generateOrRetrieveUserId();
                this.userColor = this.generateOrRetrieveUserColor();
                
                this.initializeProtobuf();
                this.setupCanvas();
                this.setupEventListeners();
                this.initializeWaku();
                this.setInitialColor();
            }

            async initializeProtobuf() {
                try {
                    this.protobufRoot = protobuf.parse(protoSchema).root;
                    this.WhiteboardMessage = this.protobufRoot.lookupType('WhiteboardMessage');
                    console.log('Protobuf initialized successfully');
                } catch (error) {
                    console.error('Failed to initialize protobuf:', error);
                }
            }

            generateOrRetrieveUserId() {
                const STORAGE_KEY = 'waku_whiteboard_user_id';
                
                // Try to get existing user ID from localStorage
                let userId = localStorage.getItem(STORAGE_KEY);
                
                if (!userId) {
                    // Generate new user ID if none exists
                    userId = 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now().toString(36);
                    
                    // Save to localStorage for future sessions
                    localStorage.setItem(STORAGE_KEY, userId);
                    console.log('Generated new user ID:', userId);
                } else {
                    console.log('Retrieved existing user ID from cache:', userId);
                }
                
                return userId;
            }

            generateOrRetrieveUserColor() {
                const STORAGE_KEY = 'waku_whiteboard_user_color';
                
                // Try to get existing user color from localStorage
                let userColor = localStorage.getItem(STORAGE_KEY);
                
                if (!userColor) {
                    // Generate new random color if none exists
                    const colors = [
                        '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
                        '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
                        '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2'
                    ];
                    userColor = colors[Math.floor(Math.random() * colors.length)];
                    
                    // Save to localStorage for future sessions
                    localStorage.setItem(STORAGE_KEY, userColor);
                    console.log('Generated new user color:', userColor);
                } else {
                    console.log('Retrieved existing user color from cache:', userColor);
                }
                
                return userColor;
            }



            setInitialColor() {
                const colorPicker = document.getElementById('colorPicker');
                colorPicker.value = this.userColor;
                this.updateBrushSettings();
                
                // Listen for color changes to update stored color
                colorPicker.addEventListener('change', () => {
                    this.userColor = colorPicker.value;
                    localStorage.setItem('waku_whiteboard_user_color', this.userColor);
                });
            }

            encodeStrokeMessage(strokeData) {
                const message = {
                    timestamp: Date.now(),
                    userId: this.userId,
                    messageId: strokeData.id,
                    stroke: {
                        id: strokeData.id,
                        points: strokeData.points.map(p => ({ x: p.x, y: p.y })),
                        color: strokeData.points[0].color,
                        size: strokeData.points[0].size
                    }
                };
                
                const errMsg = this.WhiteboardMessage.verify(message);
                if (errMsg) throw Error(errMsg);
                
                return this.WhiteboardMessage.encode(message).finish();
            }



            encodeClearMessage() {
                const message = {
                    timestamp: Date.now(),
                    userId: this.userId,
                    messageId: 'clear_' + Date.now(),
                    clear: {
                        clearAll: true
                    }
                };
                
                const errMsg = this.WhiteboardMessage.verify(message);
                if (errMsg) throw Error(errMsg);
                
                return this.WhiteboardMessage.encode(message).finish();
            }

            decodeMessage(encodedData) {
                try {
                    const decoded = this.WhiteboardMessage.decode(encodedData);
                    return this.WhiteboardMessage.toObject(decoded);
                } catch (error) {
                    console.error('Failed to decode message:', error);
                    return null;
                }
            }

            setupCanvas() {
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.updateBrushSettings();
            }

            setupEventListeners() {
                // Canvas drawing events
                this.canvas.addEventListener('mousedown', this.startDrawing.bind(this));
                this.canvas.addEventListener('mousemove', this.draw.bind(this));
                this.canvas.addEventListener('mouseup', this.stopDrawing.bind(this));
                this.canvas.addEventListener('mouseout', this.stopDrawing.bind(this));

                // Touch events for mobile
                this.canvas.addEventListener('touchstart', this.handleTouch.bind(this));
                this.canvas.addEventListener('touchmove', this.handleTouch.bind(this));
                this.canvas.addEventListener('touchend', this.stopDrawing.bind(this));



                // UI controls
                document.getElementById('colorPicker').addEventListener('change', this.updateBrushSettings.bind(this));
                document.getElementById('brushSize').addEventListener('input', this.updateBrushSettings.bind(this));
                document.getElementById('clearBtn').addEventListener('click', this.clearCanvas.bind(this));
            }



            handleIncomingMessage(wakuMessage) {
                try {
                    if (!wakuMessage.payload || !wakuMessage.payload.length || !this.WhiteboardMessage) return;

                    // Get message ID for deduplication
                    const messageId = MessageChannel.getMessageId(wakuMessage.payload);
                    if (this.seenMessages.has(messageId)) return;

                    this.seenMessages.add(messageId);

                    // Decode the message
                    const decodedMessage = this.decodeMessage(wakuMessage.payload);
                    if (!decodedMessage) return;
                    
                    console.log('Message received:', decodedMessage);
                    
                    // Only process messages from other users
                    if (decodedMessage.userId === this.userId) return;
                    
                    // Handle different message types
                    if (decodedMessage.stroke) {
                        this.drawReceivedStroke(decodedMessage.stroke, decodedMessage.userId);
                    } else if (decodedMessage.clear) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.localStrokes.clear(); // Clear local stroke tracking
                    }
                } catch (error) {
                    console.error('Failed to process received message:', error);
                }
            }

            async initializeWaku() {
                try {
                    console.log('Initializing Waku node...');
                    this.updateConnectionStatus(HealthStatus.Unhealthy);
                    
                    // Create Waku light node with default bootstrap
                    this.node = await createLightNode({ defaultBootstrap: true });
                    console.log('Waku node created');
                    
                    // Create encoder for sending messages
                    const encoder = this.node.createEncoder({ contentTopic: this.contentTopic });
                    
                    // Create message channel for collaborative board
                    this.messageChannel = MessageChannel.create(this.node, "collaborative-board", this.userId, encoder);
                    console.log('Message channel created for user ID:', this.userId);
                    
                    // Start the Waku node
                    await this.node.start();
                    console.log('Waku node started successfully');
                    
                    // Set up message event listeners
                    this.setupMessageChannelListeners();
                    
                    // Set up peer connection listeners
                    this.setupWakuHealthListeners();
                    
                    console.log('Waku whiteboard initialized successfully');
                    
                } catch (error) {
                    console.error('Failed to initialize Waku:', error);
                }
            }

            setupMessageChannelListeners() {
                // Create decoder for incoming messages
                this.decoder = this.node.createDecoder({ contentTopic: this.contentTopic });

                // Subscribe to messages
                this.messageChannel.subscribe([this.decoder]);

                // Listen for incoming messages
                this.messageChannel.addEventListener(MessageChannelEvent.InMessageReceived, (event) => {
                    console.log('Message received event:', event);
                    this.handleIncomingMessage(event.detail);
                });

                // Listen for sent messages (global feedback)
                this.messageChannel.addEventListener(MessageChannelEvent.OutMessageSent, (event) => {
                    console.log('Message sent event:', event.detail.toString().substring(0, 12) + '...');
                });

                // Initialize seenMessages for deduplication
                this.seenMessages = new Set();
            }

            setupWakuHealthListeners() {
                if (!this.node || !this.node.libp2p) return;

                // Listen for peer connections
                this.node.events.addEventListener('waku:health', (event) => {
                    console.log('Waku Health:', event.detail);
                    this.updateConnectionStatus(event.detail);
                });
            }

            startDrawing(e) {
                this.isDrawing = true;
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                this.currentStroke = [{
                    x: x,
                    y: y,
                    color: document.getElementById('colorPicker').value,
                    size: parseInt(document.getElementById('brushSize').value),
                    userId: this.userId,
                    timestamp: Date.now()
                }];

                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
            }

            draw(e) {
                if (!this.isDrawing) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.currentStroke.push({
                    x: x,
                    y: y,
                    color: this.currentStroke[0].color,
                    size: this.currentStroke[0].size,
                    userId: this.userId,
                    timestamp: Date.now()
                });

                this.ctx.lineTo(x, y);
                this.ctx.stroke();
            }

            stopDrawing() {
                if (!this.isDrawing) return;
                this.isDrawing = false;

                if (this.currentStroke.length > 1) {
                    const strokeData = {
                        id: this.generateStrokeId(),
                        points: this.currentStroke,
                        userId: this.userId,
                        timestamp: Date.now()
                    };

                    // Store the stroke as local with 'sending' status
                    this.localStrokes.set(strokeData.id, {
                        strokeData: strokeData,
                        status: 'sending'
                    });

                    // Redraw stroke with transparency
                    this.redrawStrokeWithTransparency(strokeData, 'sending');

                    // Send stroke data via Waku
                    this.sendStrokeMessage(strokeData);
                }

                this.currentStroke = [];
            }

            handleTouch(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 
                                                 e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                this.canvas.dispatchEvent(mouseEvent);
            }



            updateBrushSettings() {
                const color = document.getElementById('colorPicker').value;
                const size = parseInt(document.getElementById('brushSize').value);
                
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = size;
                
                document.getElementById('brushSizeValue').textContent = size + 'px';
            }

            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Clear local strokes tracking
                this.localStrokes.clear();
                
                const clearMessage = {
                    type: 'clear',
                    userId: this.userId,
                    timestamp: Date.now()
                };

                // Send clear message via Waku
                this.sendClearMessage(clearMessage);
            }

            generateStrokeId() {
                return 'stroke_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            // Waku message sending methods
            async sendStrokeMessage(strokeData) {
                try {
                    if (!this.messageChannel) {
                        console.warn('MessageChannel not initialized, cannot send stroke message');
                        return;
                    }
                    
                    const encodedMessage = this.encodeStrokeMessage(strokeData);
                    console.log('Sending encoded stroke message:', encodedMessage);
                    
                    // Get message ID for tracking acknowledgments
                    const messageId = MessageChannel.getMessageId(encodedMessage);
                    
                    // Set up acknowledgment listener for this specific message
                    this.messageChannel.addEventListener(MessageChannelEvent.OutMessageSent, (event) => {
                        if (messageId === event.detail) {
                            this.updateStrokeStatus(strokeData.id, 'sent');
                        }
                    });

                    this.messageChannel.addEventListener(MessageChannelEvent.OutMessageAcknowledged, (event) => {
                        if (messageId === event.detail) {
                            this.updateStrokeStatus(strokeData.id, 'acknowledged');
                        }
                    });
                    
                    // Send via Waku MessageChannel
                    await this.messageChannel.send(encodedMessage);
                    
                    // Add to pending with sending status
                    this.addPendingStroke(strokeData.id, strokeData);
                    
                } catch (error) {
                    console.error('Failed to send stroke message:', error);
                }
            }



            async sendClearMessage() {
                try {
                    if (!this.messageChannel) {
                        console.warn('MessageChannel not initialized, cannot send clear message');
                        return;
                    }
                    
                    const encodedMessage = this.encodeClearMessage();
                    console.log('Sending clear message to peers');
                    
                    // Send via Waku MessageChannel
                    await this.messageChannel.send(encodedMessage);
                    
                } catch (error) {
                    console.error('Failed to send clear message:', error);
                }
            }

            // Message handling methods
            addPendingStroke(messageId, strokeData) {
                this.pendingStrokes.set(messageId, strokeData);
                this.updatePendingStrokesUI();
            }

            markStrokeAcknowledged(messageId) {
                this.acknowledgedStrokes.add(messageId);
                this.updatePendingStrokesUI();
                
                // Remove from pending after a delay
                setTimeout(() => {
                    this.pendingStrokes.delete(messageId);
                    this.updatePendingStrokesUI();
                }, 2000);
            }

            updateStrokeStatus(strokeId, status) {
                if (status === 'sent') {
                    console.log('Stroke sent:', strokeId);
                    // Update local stroke status and redraw with new transparency
                    if (this.localStrokes.has(strokeId)) {
                        this.localStrokes.get(strokeId).status = 'sent';
                        this.redrawStrokeWithTransparency(this.localStrokes.get(strokeId).strokeData, 'sent');
                    }
                } else if (status === 'acknowledged') {
                    console.log('Stroke acknowledged:', strokeId);
                    // Update local stroke status and redraw with full opacity
                    if (this.localStrokes.has(strokeId)) {
                        this.localStrokes.get(strokeId).status = 'acknowledged';
                        this.redrawStrokeWithTransparency(this.localStrokes.get(strokeId).strokeData, 'acknowledged');
                    }
                    this.markStrokeAcknowledged(strokeId);
                }
            }

            redrawStrokeWithTransparency(strokeData, status) {
                const points = strokeData.points;
                if (!points || points.length < 2) return;

                // Clear the stroke area and redraw everything
                this.redrawCanvas();

                // Set transparency based on status
                let alpha = 1.0; // Default for acknowledged or peer strokes
                if (status === 'sending') {
                    alpha = 0.2; // 20% transparent
                } else if (status === 'sent') {
                    alpha = 0.6; // 60% transparent
                }

                // Redraw this specific stroke with transparency
                this.ctx.save();
                this.ctx.globalAlpha = alpha;
                this.ctx.beginPath();
                this.ctx.strokeStyle = points[0].color;
                this.ctx.lineWidth = points[0].size;
                this.ctx.moveTo(points[0].x, points[0].y);

                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i].x, points[i].y);
                }
                
                this.ctx.stroke();
                this.ctx.restore();
            }

            redrawCanvas() {
                // Clear the canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Redraw all acknowledged local strokes with full opacity
                this.localStrokes.forEach((strokeInfo, _strokeId) => {
                    if (strokeInfo.status === 'acknowledged') {
                        this.drawStrokeWithAlpha(strokeInfo.strokeData, 1.0);
                    } else if (strokeInfo.status === 'sent') {
                        this.drawStrokeWithAlpha(strokeInfo.strokeData, 0.75);
                    } else if (strokeInfo.status === 'sending') {
                        this.drawStrokeWithAlpha(strokeInfo.strokeData, 0.5);
                    }
                });
            }

            drawStrokeWithAlpha(strokeData, alpha) {
                const points = strokeData.points;
                if (!points || points.length < 2) return;

                this.ctx.save();
                this.ctx.globalAlpha = alpha;
                this.ctx.beginPath();
                this.ctx.strokeStyle = points[0].color;
                this.ctx.lineWidth = points[0].size;
                this.ctx.moveTo(points[0].x, points[0].y);

                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i].x, points[i].y);
                }
                
                this.ctx.stroke();
                this.ctx.restore();
            }

            drawReceivedStroke(strokeData, senderId) {
                // Store received stroke as a peer stroke with full opacity
                const peerStrokeId = `peer_${senderId}_${Date.now()}`;
                this.localStrokes.set(peerStrokeId, {
                    strokeData: strokeData,
                    status: 'acknowledged' // Peer strokes are always fully visible
                });

                // Redraw canvas to include this new stroke
                this.redrawCanvas();
            }

            updatePendingStrokesUI() {
                const pendingContainer = document.getElementById('pendingStrokes');
                const pendingList = document.getElementById('pendingList');
                
                if (this.pendingStrokes.size === 0) {
                    pendingContainer.style.display = 'none';
                    return;
                }

                pendingContainer.style.display = 'block';
                pendingList.innerHTML = '';

                this.pendingStrokes.forEach((strokeData, messageId) => {
                    const div = document.createElement('div');
                    div.className = 'pending-stroke';
                    
                    if (this.acknowledgedStrokes.has(messageId)) {
                        div.classList.add('acknowledged');
                        div.innerHTML = '<span class="checkmark">âœ“</span> Stroke delivered';
                    } else {
                        div.innerHTML = '<div class="spinner"></div> Sending stroke...';
                    }
                    
                    pendingList.appendChild(div);
                });
            }

            updateConnectionStatus(healthStatus) {
                const statusEl = document.getElementById('connectionStatus');
                if (healthStatus === HealthStatus.SufficientlyHealthy) {
                    statusEl.textContent = 'Connected';
                    statusEl.className = 'connection-status connected';
                } else if (healthStatus === HealthStatus.MinimallyHealthy) {
                    statusEl.textContent = 'Connecting';
                    statusEl.className = 'connection-status connecting';
                } else {
                    statusEl.textContent = 'Disconnected';
                    statusEl.className = 'connection-status disconnected';
                }
            }




        }

        // Initialize the whiteboard when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.whiteboard = new CollaborativeWhiteboard();
        });
    </script>
</body>
</html>